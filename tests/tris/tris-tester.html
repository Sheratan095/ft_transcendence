<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="style.css" rel="stylesheet">
</head>
<body>
    <main id="app" hidden>
        <div class="turn">
            <h2 id="myTurn" hidden>it's your turn</h2>
            <h2 id="oppoTurn" hidden>it's opponent turn</h2>
            <h2 id="playerWin" hidden>you Won</h2>
            <h2 id="enemyWin" hidden>enemy Won</h2>
            <h2 id="iaTurn" hidden>opponent Won</h2>
        </div>
        <div id="board">
            <!-- <div class="row">
                <div class="cell" id="0">X</div>
                <div class="cell" id="1"></div>
                <div class="cell" id="2">O</div>
            </div>
            <div class="row">
                <div class="cell" id="3"></div>
                <div class="cell" id="4">O</div>
                <div class="cell" id="5"></div>
            </div>
            <div class="row">
                <div class="cell" id="6">X</div>
                <div class="cell" id="7">X</div>
                <div class="cell" id="8">O</div>
            </div> -->
            <div class="row">
                <div class="cell" id="0"></div>
                <div class="cell" id="1"></div>
                <div class="cell" id="2"></div>
            </div>
            <div class="row">
                <div class="cell" id="3"></div>
                <div class="cell" id="4"></div>
                <div class="cell" id="5"></div>
            </div>
            <div class="row">
                <div class="cell" id="6"></div>
                <div class="cell" id="7"></div>
                <div class="cell" id="8"></div>
            </div>
        </div>
    </main>
    <button id="startBtn" class="button" disabled>Start</button>

    <script>
        const playerHistory = [];
        const iaHistory = [];

        const email = "test1@gmail.com";
        const password = "1234";
        const startBtn = document.getElementById('startBtn');
        const appEl = document.getElementById('app');

        const myTurn = document.getElementById('myTurn');
        const oppoTurn = document.getElementById('oppoTurn');
        const table = document.getElementById('board');
        const GATEWAY_URL = 'https://localhost:3000';
        const pWin = document.getElementById('playerWin');
        const eWin = document.getElementById('enemyWin');

        let endFlag = 0;
        let turn;
        let finish = 0;
        let event;
        let val;
        let accessToken = null;
        let totalPlayer = 0;
        let totalIa = 0;
        let total = 0;
        // let board = Array(3);
        // board[0] = Array("X", "empty", "O");
        // board[1] = Array("empty", "O", "empty");
        // board[2] = Array("X", "X", "O");
        board[0] = Array("empty", "empty", "empty");
        board[1] = Array("empty", "empty", "empty");
        board[2] = Array("empty", "empty", "empty");
        let score = 0;
        let i = 0;
        let iter = 0;
        let bestMove = null;

        /**
         * function:
         *  recursively check for pairs in a given direction until score == 2
         * return:
         *  0 if the winning combination is not found, 1 if does
         * */
        function checkAdiacent(y, x, dir, score, charSym, src)
        {
            // if (src[y][x] !== charSym) return 0;
            //  console.log("score: ", score);
            //  console.log("dir: ", dir);
            //  console.log("iteration: ", iter++);
            // console.log(charSym);
            if (score === 2)
                return (1);
            if (x + 1 < 3 && (dir === 0 || dir === 1))
            {
                if (src[y][x + 1] === charSym)
                {
                    // console.log("checking square: ", y, x);
                    // console.log(count);
                    // console.log("found right");
                    score++;
                    if (checkAdiacent(y, x + 1, 1, score, charSym, src))
                    {
                        return (1);
                    }
                    else
                    {
                        score = 0;
                    }
                }
                //return (0);
            }
            if (x - 1 >= 0 && (dir === 0 || dir === 2))
            {
                if (src[y][x - 1] === charSym)
                {
                    //console.log("found left");
                    score++;
                    if (checkAdiacent(y, x - 1, 2, score, charSym, src))
                    {
                        return (1);
                    }
                    else
                    {
                        score = 0;
                    }
                }
                //return (0);
            }
            // check under & over
            if (y + 1 < 3 && (dir === 0 || dir === 3))
            {
                if (src[y + 1][x] == charSym)
                {
                    // console.log("found bottom");
                    score++;
                    if (checkAdiacent(y + 1, x, 3, score, charSym, src))
                    {
                        return (1);
                    }
                    else
                    {
                        score = 0;
                    }
                }
            }
            if (y - 1 >= 0 && (dir === 0 || dir === 4))
            {
                if (src[y - 1][x] === charSym)
                {
                    // console.log("found top");
                    score++;
                    if (checkAdiacent(y - 1, x, 4, score, charSym, src))
                    {
                        return (1);
                    }
                    else
                    {
                        score = 0;
                    }
                }
            }
            // check diagonally down - right
            if (y + 1 < 3 && x + 1 < 3 && (dir === 0 || dir === 5))
            {
                //console.log("case down right");
                if (src[y + 1][x + 1] === charSym)
                {
                    score++;
                    if (checkAdiacent(y + 1, x + 1, 5, score, charSym, src))
                    {
                        return (1);
                    }
                    else
                    {
                        score = 0;
                    }
                }
            }
            // check diagonally up - left
            if (y - 1 >= 0 && x - 1 >= 0 && (dir === 0 || dir === 6))
            {
                if (src[y - 1][x - 1] === charSym)
                {
                    score++;
                    if (checkAdiacent(y - 1, x - 1, 6, score, charSym, src))
                    {
                        return (1);
                    }
                    else
                    {
                        score = 0;
                    }
                }
            }
            // check diagonally up - right
            if (y - 1 >= 0 && x + 1 < 3 && (dir === 0 || dir === 8))
            {
                //console.log("case diagonal2");
                if (src[y - 1][x + 1] == charSym)
                {
                    score++;
                    if (checkAdiacent(y - 1, x + 1, 8, score, charSym, src))
                    {
                        return (1);
                    }
                    else
                    {
                        score = 0;
                    }
                }
            }
            // check diagonally down - left
            if (y + 1 < 3 && x - 1 >= 0 && (dir === 0 || dir === 7))
            {
                if (src[y + 1][x - 1] === charSym)
                {
                    //console.log("case diagonal");
                    score++;
                    if (checkAdiacent(y + 1, x - 1, 7, score, charSym, src))
                    {
                        return (1);
                    }
                    else
                    {
                        score = 0;
                    }
                }
            }
            return (0);
        }

        /**
         * function:
         *  calls a checkAdiacent on each cell of the board
         * return:
         *  1 if the player won, 0 if not
         * */
        function checkWin(charSym, src, realMode)
        {
            // score = 3;
            //console.log("new turn");
            for (let i = 0; i < 3; i++)
            {
                for (let j = 0; j < 3; j++)
                {
                    //console.log("y - x", i, j);
                    if (src[i][j] === charSym)
                    {
                        score = 0;
                        iter = 0;
                        //  console.log("checking");
                        //  console.log("y - x", i, j);
                        if (checkAdiacent(i, j, 0, score, charSym, src))
                        {
                            if (realMode)
                            {
                                if (charSym === 'X')
                                {
                                    console.log("player won");
                                    pWin.hidden = false;
                                    endFlag = 1;
                                }
                                else
                                {
                                    endFlag = 1;
                                    console.log("enemyWon");
                                    eWin.hidden = false;
                                }
                            }
                            return (1);
                        }
                    }
                }
            }
            return (0);
        }

        // check if a given move is valid
        function isMoveValid(value, board)
        {
            let fixed = value;
            if (fixed === 0)
                fixed++;
            let x = value % 3;
            let y = Math.floor(fixed / 3);

            if (board[y][x] === "X"
                || board[y][x] === "O")
            {
                return (1);
            }
            return (0);
        }

        // return the highest number of an array
        function indexOfMax(arr)
        {
            if (arr.length === 0) {
                return -1;
            }

            var max = arr[0];
            var maxIndex = 0;

            for (var i = 1; i < arr.length; i++) {
                if (arr[i] > max) {
                    maxIndex = i;
                    max = arr[i];
                }
            }

            return maxIndex;
        }

        // copy a nested array
        function boardCopy(src)
        {
            let tmp = Array(3);
            tmp[0] = Array("empty", "empty", "empty");
            tmp[1] = Array("empty", "empty", "empty");
            tmp[2] = Array("empty", "empty", "empty");
            let i = 0;
            let j = 0;
            //console.log(tmp);
            while (i < 3)
            {
                j = 0;
                while (j < 3)
                {
                    tmp[i][j] = src[i][j];
                    j++;
                }
                i++;
            }
            return (tmp);
        }

        // calculate score for a given move index
        function calculateScore(index, board, isMax, depth)
        {
            let score = 0;
            let fixed = index;
            if (fixed === 0)
                fixed++;
            let x = index % 3;
            let y = Math.floor(fixed / 3);
            let tmpBoard = boardCopy(board);
            let moveScore = 0;
            let symbol;

            //console.log(checkAdiacent(y, x, 0, 2, 'O'));
            //moveScore--;

            // console.log(board);
            if (isMax)
                symbol = 'O';
            else
                symbol = 'X';

            tmpBoard[y][x] = symbol;

            let moves = findPossibleMoves(tmpBoard);
            //console.log(possibleMoves)

            //console.log("myboard", tmpBoard, depth);
            // let win = 0;
            // if (possibleMoves.length === 0)
            // {
            //     //console.log(tmpBoard);
            //     return (0);
            // }
            if (checkWin(symbol, tmpBoard, 0))
            {
                //console.log("found winning move at: ", index);
                //console.log(tmpBoard);
                //win = 1;
                //moveScore = moveScore + 10;
                return ((isMax > 0 ? 10 : -10) - depth);
            }
            // if (checkAdiacent(y, x, 0, score, 'X', tmpBoard))
            // {
            //     console.log("found winning move for enemy: ", index);
            //     //moveScore = moveScore - 10;
            //     return (-10);
            // }
            
            if (moves.length === 0)
            {
                 //console.log(tmpBoard);
                 return (0);
            }

            //const enemyOutcomes = [];
            //possibleMoves.forEach(element => {
                //let newBoard = boardCopy(tmpBoard);
                // console.log("new: ", newBoard);
                // let fix2 = element;
                // if (fix2 === 0)
                //     fix2++;
                // let q = element % 3;
                // let w = Math.floor(fix2 / 3);
                //newBoard[w][q] = 'X';
                // calculateScore()
                // console.log("boardTmp: ", tmpBoard);
                // console.log("boardPlayer: ", newBoard);

                // if (checkAdiacent(w, q, 0, score, 'X', newBoard))
                // {
                //     // console.log("found winning move for enemy: ", index);
                //     //moveScore = moveScore - 10;
                //     moveScore -= 10;
                //     return ;
                // }
                // if (checkAdiacent(w, q, 0, 0, 'X', newBoard)) {
                //     enemyOutcomes.push(-10);
                //     return;
                // }
                // let possibleIndexes = findPossibleMoves(newBoard);
                // if (possibleIndexes.length === 0) {
                //     enemyOutcomes.push(0);
                //     return;
                // }

                //moveScore += calculateScore(element, tmpBoard, !isMax, ++depth);

                // possibleIndexes.forEach(element => {
                //     moveScore += calculateScore(element, newBoard);
                // });

                // O moves next; take its best response
                // const oResponses = possibleIndexes.map(e => calculateScore(e, newBoard));
                // enemyOutcomes.push(Math.max(...oResponses));

            //});

            if (isMax) {
                let best = Infinity;
                for (const m of moves) {
                    best = Math.min(best, calculateScore(m, tmpBoard, false, depth + 1));
                }
                return best;
            }
            else 
            {
                let best = -Infinity;
                for (const m of moves) {
                    best = Math.max(best, calculateScore(m, tmpBoard, true, depth + 1));
                }
                return best;
            }
            // if (enemyOutcomes.length === 0) {
            //     return 0;
            // }
            // Enemy chooses the worst outcome for us
            //return Math.min(...enemyOutcomes);
            //virtualBoard[index] = 'O';

            // console.log("board: ", tmpBoard);
            //console.log("virtual board: ", board);
            //console.log(tmpBoard);
            return (moveScore);
        }

        // find all possible moves for a given board state
        function findPossibleMoves(board)
        {
            let tmp = [];
            let value = 0;
            while (value < 9)
            {
                if (!isMoveValid(value, board))
                    tmp.push(value);
                value++;
            }
            return (tmp);
        }

        // find best move for IA
        function findBestMove()
        {
            let possibleMoves = [];
            let value = 0;
            let selectedIndex = null;
            let moveScores = [];
            let virtualBoard = boardCopy(board);

            // console.log(value);
            //console.log("old board: ", virtualBoard);
            possibleMoves = findPossibleMoves(virtualBoard);
            //console.log("possible moves: ", possibleMoves);
            let movesNum = possibleMoves.length;
            //console.log(movesNum);

            let i = 0;
            possibleMoves.forEach(element => {
                moveScores[i] = calculateScore(element, virtualBoard, 1, 0);
                i++;
            });

            //console.log(virtualBoard);
            console.log("move scores: ", moveScores);
            let selected = indexOfMax(moveScores);

            value = possibleMoves[selected];
            let fixed = value;
            if (fixed === 0)
                fixed++;
            let x = value % 3;
            let y = Math.floor(fixed / 3);

            //console.log(x, y);
            let valueStr = value.toString();
            let cell = document.getElementById(valueStr).textContent = "O";
            iaHistory.push(value);
            let move = Array(y, x);
            console.log("board: ", board);
            return (move);
        }

        // puts the selected move on UI
        function executeMove(x, y)
        {
            board[y][x] = "O";
            return (0);
        }

        // remove a move from the board
        function removeFromBoard(index)
        {
            let value = index;
            let fixed = value;
            if (value === 0)
                fixed++;
            let x = value % 3;
            let y = Math.floor(fixed / 3);

            let valueStr = value.toString();
            board[y][x] = "empty";
            document.getElementById(valueStr).textContent = "";
            //console.log(board);
            // console.log("removed index: ", index);
            // console.log("y - x: ", y, x);
        }

        // change turn logic
        function nextTurn()
        {
            // console.log("passing trough next turn");
            // console.log(endFlag);
            if (endFlag)
            {
                console.log("exiting correctly");
                return (1);
            }
            // console.log(board);
            //console.log("player won");
            if (turn === 0)
            {
                myTurn.hidden = false;
                //oppoTurn.hidden = true;
                if (handlePlayerTurn())
                {
                    console.log("shutting down");
                    console.log(endFlag);
                    return (1);
                }
            }
            else
            {
                oppoTurn.hidden = false;
                totalIa++;
                if (handleIaTurn())
                {
                    console.log("shutting down");
                    return (1);
                }
            }
            total++;
        }

        // handle player move
        function handlePlayerTurn(event)
        {
            // if (totalPlayer >= 4)
            // {
            //     removeFromBoard(playerHistory[totalPlayer - 4]);
            // }
            //console.log("player turn");
            // if (checkWin('X'))
            // {
            //     console.log("passed trough player turn");
            //     return (1);
            // }
            totalPlayer++;
        }

        // handle ia move
        function handleIaTurn()
        {
            let selectedMove = null;
            //console.log(board);

            if (endFlag === 1)
            {
                console.log("game already ended, skipping");
                return (1);
            }

            selectedMove = findBestMove();
            turn = 0;

            let y = selectedMove[0];
            let x = selectedMove[1];
            executeMove(x, y);

            // if (totalIa >= 4)
            // {
            //     removeFromBoard(iaHistory[totalIa - 4]);
            // }
            if (checkWin('O', board, 1))
            {
                console.log("exiting from IA move");
                endFlag = 1;
                return (1);
            }
            if (endFlag < 1)
                nextTurn();
            else
                console.log("skipping next turn");
        }

        // get random number
        function getInt(max)
        {
            return Math.floor(Math.random() * max);
        }

        // moves listener
        table.addEventListener('click', async (event) =>
        {
            if (endFlag === 0)
            {
                let value = event.target.id;
                let fixed = value;
                if (value === 0)
                    fixed++;
                let x = value % 3;
                let y = Math.floor(fixed / 3);

                if (board[y][x] === "X"
                    || board[y][x] === "O")
                {
                    console.log(board);
                    console.log("invalid cell");
                    return;
                }
                let valueStr = value.toString();
                let cell = document.getElementById(valueStr).textContent = "X";
                playerHistory.push(value);
                turn = 1;
                board[y][x] = "X";

                if (checkWin('X', board, 1))
                {
                    console.log("ended in player move listener");
                    return (1);
                }

                if (endFlag < 1)
                {
                    // console.log("calling next turn after a move");
                    if (nextTurn())
                    {
                        console.log("exiting from move listener");
                        return (1);
                    }
                }
                else
                {
                    console.log("game ended, skipping next turn");
                    return (1);
                }
            }
        });

        // game init
        startBtn.addEventListener('click', async () => {
            //console.log('startBtn clicked');
            try {
                const response = await fetch(`${GATEWAY_URL}/tris/init`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include' // Important for cookies
                });

                if (response.ok) {
                    appEl.hidden = false;
                    turn = getInt(2);
                    //turn = 1;
                    nextTurn();
                }
                else
                {
                    console.error('Init failed with status:', response.status);
                    alert('Failed to initialize game');
                }
            } catch (err) {
                console.error('Error initializing game:', err);
                alert('Error: ' + err.message);
            }
        });

        // login
        window.addEventListener('DOMContentLoaded', async () => {
            try {
            const response = await fetch(`${GATEWAY_URL}/auth/login`, {
                method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include', // Important for cookies
                    body: JSON.stringify({ email, password })
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log('Login successful:', data);
                    startBtn.disabled = false;
                } else {
                    console.error('Login failed with status:', response.status);
                    alert('Login failed');
                }
            } catch (err) {
                console.error('Login error:', err);
                alert('Error during login: ' + err.message);
            }
        });

    </script>

</body>
</html>