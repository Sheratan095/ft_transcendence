/**
 * Tris Input Controllers
 * Handles user interaction for local, AI, and online modes
 */

export interface InputController {
	onMove: (callback: (position: number) => void) => void;
	destroy: () => void;
}

/**
 * Handles clicks on the game board for local human player
 */
export class LocalInputController implements InputController {
	private callback?: (position: number) => void;
	private boardElement: HTMLElement | null = null;

	constructor() {
		this.boardElement = document.getElementById('tris-board');
		if (this.boardElement) {
			this.boardElement.addEventListener('click', this.handleClick);
		}
	}

	onMove(callback: (position: number) => void) {
		this.callback = callback;
	}

	private handleClick = (event: MouseEvent) => {
		const target = event.target as HTMLElement;
		const cellIndex = target.dataset.index;
		if (cellIndex !== undefined && this.callback) {
			this.callback(parseInt(cellIndex));
		}
	}

	destroy() {
		if (this.boardElement) {
			this.boardElement.removeEventListener('click', this.handleClick);
		}
	}
}

/**
 * Handles moves generated by the AI agent
 */
export class AIController implements InputController {
	private callback?: (position: number) => void;
	private gameState: any;
	private symbol: string;

	constructor(gameState: any, symbol: string) {
		this.gameState = gameState;
		this.symbol = symbol;
	}

	onMove(callback: (position: number) => void) {
		this.callback = callback;
	}

	// AI logic will be called explicitly by GameManager when it's AI's turn
	async generateMove(): Promise<void> {
		if (!this.callback) return;

		// Add a small delay to simulate thinking
		await new Promise(resolve => setTimeout(resolve, 800));

		const { getBestMove } = await import('./physics');
		const move = getBestMove(this.gameState);
		if (move !== -1) {
			this.callback(move);
		}
	}

	destroy() {}
}

/**
 * Handles moves coming from the network (over WebSocket)
 */
export class NetworkInputController implements InputController {
	private callback?: (position: number) => void;

	constructor() {}

	onMove(callback: (position: number) => void) {
		this.callback = callback;
	}

	handleNetworkMove(position: number) {
		if (this.callback) {
			this.callback(position);
		}
	}

	destroy() {}
}
